import { Request, Response } from "express";
import { getDateRange } from "../../utils";
import {
  DownloadHistoryModel,
  TransactionModel,
} from "../../models/Transaction";
import {
  AnalyticsFilterRange,
  VehicleStatusEnum,
  PaymentStatusEnum,
  RoleName,
  VehicleTypeEnum,
  PaymentTypeEnum,
  AccountStatusEnum,
} from "../../types";
import { withMongoTransaction } from "../../utils/mongoTransaction";
import { WalletService } from "../../services/wallet.service";
import { VendorModel } from "../../models/Vendor";
import { Vehicle } from "../../models/Vehicle";
import { AssociationModel } from "../../models/Association";
import { DepositWalletModel, WalletTypeEnum } from "../../models/Wallet";
import { AnalyticsService } from "../../services/analytics.service";
import { UserModel } from "../../models/User";
import { header, query, validationResult } from "express-validator";
import InvoiceModel, { InvoiceStatusEnum } from "../../models/Invoice";
import { PaymentTypeModel } from "../../models/PaymentType";
import { DriverModel } from "../../models/Driver";
import mongoose from "mongoose";

export class Analytics {
  static async Main(req: Request, res: Response) {
    const userId = req.headers["userid"] as string;

    await header("userid").isMongoId().withMessage("Invalid user id").run(req);

    const errors = validationResult(req);

    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: errors.array()?.[0]?.msg,
        errors: errors.array(),
      });
    }

    // verify account
    const consultantUserAccount = await UserModel.findById(userId);

    if (!consultantUserAccount) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    if (consultantUserAccount.role !== RoleName.SuperAdmin) {
      return res.status(403).json({
        success: false,
        message: "You do not have permission to access this resource",
      });
    }

    const { filter = AnalyticsFilterRange.DAILY, year, status } = req.query;

    try {
      const { startDate, endDate } = getDateRange(
        filter as AnalyticsFilterRange,
        parseInt(year as string)
      );

      const result = await withMongoTransaction(async (session) => {
        const matchConditions: any = {
          date: { $gte: startDate, $lte: endDate },
        };

        // If a status is provided in the query, use it; otherwise, match all relevant statuses
        if (status) {
          matchConditions.status = status;
        } else {
          matchConditions.status = {
            $in: [
              PaymentStatusEnum.SUCCESSFUL,
              PaymentStatusEnum.PENDING,
              PaymentStatusEnum.CANCELLED,
              PaymentStatusEnum.REVERSED,
            ],
          };
        }

        // overall total transactions and revenue generated within today
        const overallTotalTransactionsAndRevenueToday =
          await AnalyticsService.getOverallTotalTransactionsAndRevenue({});

        // overall total transactions and revenue generated till date
        const overallTransactionsAndRevenueTillDate =
          await AnalyticsService.getOverallTotalTransactionsAndRevenue({
            filter: AnalyticsFilterRange.OVERALL,
          });

        // get total transactions based on date and group by statuses
        const transactions = await TransactionModel.aggregate([
          {
            $match: matchConditions,
          },
          {
            $group: {
              _id: null,
              successful: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", PaymentStatusEnum.SUCCESSFUL] },
                    1,
                    0,
                  ],
                },
              },
              pending: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", PaymentStatusEnum.PENDING] },
                    1,
                    0,
                  ],
                },
              },
              canceled: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", PaymentStatusEnum.CANCELLED] },
                    1,
                    0,
                  ],
                },
              },
              reversed: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", PaymentStatusEnum.REVERSED] },
                    1,
                    0,
                  ],
                },
              },
            },
          },
        ]).session(session);

        // If no transactions found, return 0 values to avoid undefined errors
        const transactionSummary = transactions[0] || {
          successful: 0,
          pending: 0,
          canceled: 0,
          reversed: 0,
        };

        // overall total transactions and revenue generated by consultant till date
        const overallConsultantRevenueTillDate =
          await AnalyticsService.getOverallTotalTransactionsAndRevenueByUserId({
            userId: consultantUserAccount._id,
            session,
          });

        // get total transactions and revenue generated by consultant based on filter
        const filteredConsultantRevenue =
          await AnalyticsService.getOverallTotalTransactionsAndRevenueByUserId({
            userId: consultantUserAccount._id,
            filter: filter as AnalyticsFilterRange,
            year: parseInt(year as string),
            session,
          });

        // tax payment analytics
        const overallTaxRevenue =
          await AnalyticsService.getOverallTaxRevenueAndTransactions({
            filter: AnalyticsFilterRange.OVERALL,
          });
        const filteredTaxRevenue =
          await AnalyticsService.getOverallTaxRevenueAndTransactions({
            filter: filter as AnalyticsFilterRange,
            year: parseInt(year as string),
          });

        return {
          today: {
            revenueToday: overallTotalTransactionsAndRevenueToday.totalAmount,
            totalTransactionsToday:
              overallTotalTransactionsAndRevenueToday.totalTransactions,
          },
          overallRevenueGenerated: {
            totalTransactions:
              overallTransactionsAndRevenueTillDate.totalTransactions,
            totalRevenue: overallTransactionsAndRevenueTillDate.totalAmount,
          },
          transactions: {
            ...transactionSummary,
          },
          tax: {
            overallTaxRevenue: {
              totalRevenue: overallTaxRevenue.totalTaxRevenue,
              totalTransactions: overallTaxRevenue.totalTransactions,
              dataPoints: overallTaxRevenue.dataPoints,
            },
            filteredTaxRevenue: {
              totalRevenue: filteredTaxRevenue.totalTaxRevenue,
              totalTransactions: filteredTaxRevenue.totalTransactions,
              dataPoints: filteredTaxRevenue.dataPoints,
            },
          },
          consultantRevenue: {
            overallRevenue: overallConsultantRevenueTillDate.totalAmount,
            overallTransactions:
              overallConsultantRevenueTillDate.totalTransactions,
            dataPoints: overallConsultantRevenueTillDate.dataPoints,
            filteredConsultantRevenue: {
              revenue: filteredConsultantRevenue.totalAmount,
              transactions: filteredConsultantRevenue.totalTransactions,
              dataPoints: filteredConsultantRevenue.dataPoints,
            },
          },
        };
      });

      return res.status(200).json({
        success: true,
        message: "Tax analytics fetched successfully",
        data: result,
      });
    } catch (error: any) {
      return res.status(500).json({
        success: false,
        message: "There was a problem getting tax analytics",
        error: error.message || error,
      });
    }
  }

  static async vehicles(req: Request, res: Response) {
    const {
      filter = AnalyticsFilterRange.DAILY,
      year,
      status,
      type,
    } = req.query;

    const { startDate, endDate } = getDateRange(
      filter as AnalyticsFilterRange,
      parseInt(year as string)
    );
    try {
      const result = await withMongoTransaction(async (session) => {
        // get total vehicles registered today
        const totalVehiclesRegisteredToday = await Vehicle.countDocuments({
          createdAt: { $gte: new Date().setHours(0, 0, 0, 0) },
        }).session(session);

        const filteredTotalVehiclesRegistered = await Vehicle.aggregate([
          {
            $match: {
              createdAt: { $gte: startDate, $lte: endDate },
              ...(type ? { vehicleType: type } : {}),
            },
          },
          {
            $group: {
              _id: null,
              total: { $sum: 1 },
            },
          },
        ]).session(session);

        const totalVehiclesByStatus =
          await AnalyticsService.getTotalVehiclesByStatus(
            (status as VehicleStatusEnum) || VehicleStatusEnum.ACTIVATED,
            session
          );

        const allVehiclesByStatus = await Vehicle.aggregate([
          {
            $group: {
              _id: null,
              activated: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", VehicleStatusEnum.ACTIVATED] },
                    1,
                    0,
                  ],
                },
              },
              inactive: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", VehicleStatusEnum.INACTIVE] },
                    1,
                    0,
                  ],
                },
              },
              blacklisted: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", VehicleStatusEnum.BLACKLISTED] },
                    1,
                    0,
                  ],
                },
              },
              notActivated: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", VehicleStatusEnum.NOT_ACTIVATED] },
                    1,
                    0,
                  ],
                },
              },
              suspended: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", VehicleStatusEnum.SUSPENDED] },
                    1,
                    0,
                  ],
                },
              },
            },
          },
        ]).session(session);

        const vehicleStatusCounts = allVehiclesByStatus[0] || {
          activated: 0,
          inactive: 0,
          blacklisted: 0,
          notActivated: 0,
          suspended: 0,
        };

        // if no type is provided, it returns the overall vehicle count
        const overallVehicleCount =
          await AnalyticsService.getTotalVehiclesByType(
            type as VehicleTypeEnum,
            session
          );

        return {
          totalVehiclesRegisteredToday,
          totalVehiclesByStatus,
          filteredTotalVehiclesRegistered:
            filteredTotalVehiclesRegistered[0]?.total || 0,
          vehicleStatusCounts,
          overallVehicleCount,
        };
      });

      return res.status(200).json({
        success: true,
        message: "Vehicle analytics fetched successfully",
        data: result,
      });
    } catch (error: any) {
      return res.status(500).json({
        success: false,
        message: "There was a problem getting vehicle analytics",
        error: error.message || error,
      });
    }
  }

  static async drivers(req: Request, res: Response) {
    const {
      filter = AnalyticsFilterRange.DAILY,
      year,
      status,
    } = req.query;

    const { startDate, endDate } = getDateRange(
      filter as AnalyticsFilterRange,
      parseInt(year as string)
    );
    try {
      const result = await withMongoTransaction(async (session) => {
        // get total drivers registered today
        const totalDriversRegisteredToday = await DriverModel.countDocuments({
          createdAt: { $gte: new Date().setHours(0, 0, 0, 0) },
        }).session(session);

        const filteredTotalDriversRegistered = await DriverModel.aggregate([
          {
            $match: {
              createdAt: { $gte: startDate, $lte: endDate },
            },
          },
          {
            $group: {
              _id: null,
              total: { $sum: 1 },
            },
          },
        ]).session(session);

        // get drivers by status
        const allDriversByStatus = await DriverModel.aggregate([
          {
            $group: {
              _id: null,
              active: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", AccountStatusEnum.ACTIVE] },
                    1,
                    0,
                  ],
                },
              },
              inactive: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", AccountStatusEnum.INACTIVE] },
                    1,
                    0,
                  ],
                },
              },
              suspended: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", AccountStatusEnum.SUSPENDED] },
                    1,
                    0,
                  ],
                },
              },
              deleted: {
                $sum: {
                  $cond: [
                    { $eq: ["$status", AccountStatusEnum.DELETED] },
                    1,
                    0,
                  ],
                },
              }
            },
          },
        ]).session(session);

        const driverStatusCounts = allDriversByStatus[0] || {
          active: 0,
          inactive: 0,
          blacklisted: 0,
          suspended: 0,
        };

        // get drivers with expired permits
        const driversWithExpiredPermits = await DriverModel.countDocuments({
          "permit.expiryDate": { $lt: new Date() },
        }).session(session);

        // get drivers registration trend over time
        const driverRegistrationTrend = await DriverModel.aggregate([
          {
            $match: {
              createdAt: { $gte: startDate, $lte: endDate },
            },
          },
          {
            $group: {
              _id: {
                month: { $month: "$createdAt" },
                year: { $year: "$createdAt" },
              },
              count: { $sum: 1 },
            },
          },
          { $sort: { "_id.year": 1, "_id.month": 1 } },
          {
            $project: {
              date: {
                $concat: [
                  { $toString: "$_id.year" },
                  "-",
                  { $toString: "$_id.month" },
                ],
              },
              count: 1,
              _id: 0,
            },
          },
        ]).session(session);

        return {
          totalDriversRegisteredToday,
          filteredTotalDriversRegistered: filteredTotalDriversRegistered[0]?.total || 0,
          driverStatusCounts,
          driversWithExpiredPermits,
          registrationTrend: driverRegistrationTrend,
        };
      });

      return res.status(200).json({
        success: true,
        message: "Driver analytics fetched successfully",
        data: result,
      });
    } catch (error: any) {
      return res.status(500).json({
        success: false,
        message: "There was a problem getting driver analytics",
        error: error.message || error,
      });
    }
  }

  static async printAndDownloads(req: Request, res: Response) {
    const {
      filter = AnalyticsFilterRange.DAILY,
      year,
      status,
      type,
      userId,
    } = req.query;

    const { startDate, endDate } = getDateRange(
      filter as AnalyticsFilterRange,
      parseInt(year as string)
    );
    try {
      const result = await withMongoTransaction(async (session) => {
        // confirm user
        const user = await UserModel.findById(userId).session(session);

        if (!user) {
          throw {
            status: 404,
            message: "User not found",
          };
        }

        // get total downloads or printings today
        const totalPrintsAndDownloadsToday =
          await DownloadHistoryModel.countDocuments({
            createdAt: {
              $gte: new Date().setHours(0, 0, 0, 0),
            },
          });

        const filteredTotalPrintsOrDownloads =
          await DownloadHistoryModel.aggregate([
            {
              $match: {
                createdAt: {
                  $gte: startDate,
                  $lte: endDate,
                },
                ...(type ? { type } : {}),
              },
            },
            {
              $group: {
                _id: null,
                total: { $sum: 1 },
              },
            },
          ]).session(session);

        // total downloads by type
        const totalPrintsOrDownloadsByType =
          await DownloadHistoryModel.aggregate([
            {
              $match: {
                createdAt: {
                  $gte: startDate,
                  $lte: endDate,
                },
              },
            },
            {
              $group: {
                _id: "$type", // Group by the 'type' field which refers to PaymentTypeEnum
                totalDownloads: { $sum: 1 }, // Sum the count for each type
              },
            },
            {
              $lookup: {
                from: "paymenttypes", // Reference the PaymentType collection
                localField: "_id",
                foreignField: "_id",
                as: "paymentTypeDetails",
              },
            },
            {
              $unwind: "$paymentTypeDetails",
            },
            {
              $project: {
                _id: 0, // Exclude the default _id field
                type: "$paymentTypeDetails.name", // Use the name of the payment type
                totalDownloads: 1,
              },
            },
          ]).session(session);

        // get total downloads or printings by user
        const totalPrintsOrDownloadsByUser =
          await AnalyticsService.getTotalPrintsAndDownloadsByUser({
            userId: userId as string,
            filter: filter as AnalyticsFilterRange,
            year: parseInt(year as string),
          });

        return {
          totalPrintsAndDownloadsToday,
          filteredTotalPrintsOrDownloads:
            filteredTotalPrintsOrDownloads[0]?.total,
          totalPrintsOrDownloadsByType,
          totalPrintsOrDownloadsByUser,
        };
      });

      return res.status(200).json({
        success: true,
        message: "Print and download analytics fetched successfully",
        data: result,
      });
    } catch (error: any) {
      return res.status(500).json({
        success: false,
        message: "There was a problem getting print and download analytics",
        error: error.message || error,
      });
    }
  }

  static async invoices(req: Request, res: Response) {
    const userId = req.headers["userid"] as string;
    const {
      filter = AnalyticsFilterRange.DAILY,
      year,
      status,
      type,
    } = req.query;

    const { startDate, endDate } = getDateRange(
      filter as AnalyticsFilterRange,
      parseInt(year as string)
    );

    // validate via express-validator
    await header("userid").isMongoId().withMessage("Invalid user id").run(req);
    await query("filter").isIn(Object.values(AnalyticsFilterRange)).run(req);
    await query("year").optional().isNumeric().run(req);
    await query("status")
      .optional()
      .isIn(Object.values(InvoiceStatusEnum))
      .run(req);
    await query("type")
      .optional()
      .isIn(Object.values(PaymentTypeEnum))
      .run(req);

    const errors = validationResult(req);

    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: errors.array()?.[0]?.msg,
        errors: errors.array(),
      });
    }

    try {
      const result = await withMongoTransaction(async (session) => {
        // confirm user
        const user = await UserModel.findById(userId).session(session);

        if (!user) {
          throw {
            status: 404,
            message: "User not found",
          };
        }
        let invoiceType: any;
        if (type) {
          invoiceType = await PaymentTypeModel.findOne({ name: type }).session(
            session
          );
          if (!invoiceType) {
            throw {
              status: 404,
              message: "Invoice type not found",
            };
          }
        }

        // get total invoices today
        const totalInvoicesToday = await InvoiceModel.countDocuments({
          createdAt: {
            $gte: new Date().setHours(0, 0, 0, 0),
          },
        });

        // get total invoice paid for today
        const totalInvoicePaidToday = await InvoiceModel.countDocuments({
          createdAt: {
            $gte: new Date().setHours(0, 0, 0, 0),
          },
          invoiceStatus: InvoiceStatusEnum.PAID,
        });

        const filteredTotalInvoices = await InvoiceModel.aggregate([
          {
            $match: {
              createdAt: {
                $gte: startDate,
                $lte: endDate,
              },
              ...(type ? { type: invoiceType._id } : {}),
            },
          },
          {
            $group: {
              _id: null,
              total: { $sum: 1 },
            },
          },
        ]).session(session);

        // total invoices by type
        const paymentTypes = await PaymentTypeModel.find({
          name: {
            $nin: [
              PaymentTypeEnum.JEGA,
              PaymentTypeEnum.OKADA,
              PaymentTypeEnum.TAXI,
              PaymentTypeEnum.TRICYCLE,
            ],
          },
        }).session(session);

        // Step 2: Aggregate and calculate total invoices for each payment type
        const overallTotalInvoicesByType = await Promise.all(
          paymentTypes.map(async (paymentType) => {
            const result = await InvoiceModel.aggregate([
              {
                $match: {
                  createdAt: {
                    $gte: startDate,
                    $lte: endDate,
                  },
                  type: paymentType._id, // Match the PaymentTypeEnum by its ID reference
                },
              },
              {
                $group: {
                  _id: null,
                  totalInvoices: { $sum: 1 }, // Sum the invoices for this type
                },
              },
            ]).session(session);

            return {
              type: paymentType.name, // Payment type name (e.g., CERTIFICATE_PRINTING)
              totalInvoices: result[0]?.totalInvoices || 0, // Default to 0 if no invoices found
            };
          })
        );

        // get total invoices by user
        const totalInvoicesByUser =
          await AnalyticsService.getTotalInvoicesCreatedByUser({
            userId: userId as string,
            filter: filter as AnalyticsFilterRange,
            ...((year && { year: parseInt(year as string) }) || {}),
          });

        // get total invoices by status
        const totalInvoicesByStatus = await InvoiceModel.aggregate([
          {
            $match: {
              createdAt: {
                $gte: startDate,
                $lte: endDate,
              },
            },
          },
          {
            $group: {
              _id: "$status",
              totalInvoices: { $sum: 1 },
            },
          },
          {
            $lookup: {
              from: "invoicestatus",
              localField: "_id",
              foreignField: "_id",
              as: "invoiceStatusDetails",
            },
          },
          {
            $unwind: "$invoiceStatusDetails",
          },
          {
            $project: {
              _id: 0,
              status: "$invoiceStatusDetails.name",
              totalInvoices: 1,
            },
          },
        ]).session(session);

        return {
          today: {
            totalInvoicesToday,
            totalInvoicePaidToday,
          },
          filteredTotalInvoices: filteredTotalInvoices[0]?.total,
          overallTotalInvoicesByType,
          totalInvoicesByUser,
          totalInvoicesByStatus,
        };
      });

      return res.status(200).json({
        success: true,
        message: "Invoice analytics fetched successfully",
        data: result,
      });
    } catch (error: any) {
      return res.status(500).json({
        success: false,
        message: "There was a problem getting invoice analytics",
        error: error.message || error,
      });
    }
  }

  static async government(req: Request, res: Response) {
    const { filter = AnalyticsFilterRange.DAILY, year, status } = req.query;
    const userId = req.headers["userid"] as string;

    const govtUserAccount = await UserModel.findOne({
      role: RoleName.Government,
    });

    if (!govtUserAccount) {
      return res.status(404).json({
        success: false,
        message: "Government account not found",
      });
    }

    try {
      const { startDate, endDate } = getDateRange(
        filter as AnalyticsFilterRange,
        parseInt(year as string)
      );

      const result = await withMongoTransaction(async (session) => {
        const matchConditions: any = {
          date: { $gte: startDate, $lte: endDate },
          status: PaymentStatusEnum.SUCCESSFUL,
        };

        // overall revenue generated today > set based on transactions that the government is a beneficiary to only
        const overallTotalTransactionsAndRevenueToday =
          await AnalyticsService.getOverallUserInvolvedTransactionsAndRevenue({
            filter: AnalyticsFilterRange.DAILY,
            userId: govtUserAccount._id,
            session,
          });

        // overall total transactions and revenue generated till date > set based on transactions that the government is a beneficiary to only
        const overallTransactionsAndRevenueTillDate =
          await AnalyticsService.getOverallUserInvolvedTransactionsAndRevenue({
            filter: AnalyticsFilterRange.OVERALL,
            userId: govtUserAccount._id,
            session,
          });

        // overall total trxs and revenue generated by the government till date
        const overallGovtRevenueTillDate =
          await AnalyticsService.getOverallTotalTransactionsAndRevenueByUserId({
            userId: govtUserAccount._id,
            session,
          });

        // get total transactions and revenue generated by the government based on filter
        const filteredGovtRevenue =
          await AnalyticsService.getOverallTotalTransactionsAndRevenueByUserId({
            userId: govtUserAccount._id,
            filter: filter as AnalyticsFilterRange,
            year: parseInt(year as string),
            session,
          });

        // tax payment analytics
        const overallTaxRevenue =
          await AnalyticsService.getOverallTaxRevenueAndTransactions({
            filter: AnalyticsFilterRange.OVERALL,
          });
        const filteredTaxRevenue =
          await AnalyticsService.getOverallTaxRevenueAndTransactions({
            filter: filter as AnalyticsFilterRange,
            year: parseInt(year as string),
          });

        const wallet = await WalletService.getWalletByOwnerId(
          userId,
          WalletTypeEnum.EARNINGS,
          session
        );

        return {
          today: {
            revenueToday: overallTotalTransactionsAndRevenueToday.totalAmount,
            totalTransactionsToday:
              overallTotalTransactionsAndRevenueToday.totalTransactions,
          },
          overallRevenueGenerated: {
            totalTransactions:
              overallTransactionsAndRevenueTillDate.totalTransactions,
            totalRevenue: overallTransactionsAndRevenueTillDate.totalAmount,
            dataPoints: overallTransactionsAndRevenueTillDate.dataPoints,
          },
          overallGovtRevenue: {
            totalRevenue: overallGovtRevenueTillDate.totalAmount,
            totalTransactions: overallGovtRevenueTillDate.totalTransactions,
          },
          filteredGovtRevenue: {
            revenue: filteredGovtRevenue.totalAmount,
            transactions: filteredGovtRevenue.totalTransactions,
            dataPoints: filteredGovtRevenue.dataPoints,
          },
          tax: {
            overallTaxRevenue: {
              totalRevenue: overallTaxRevenue.totalTaxRevenue,
              totalTransactions: overallTaxRevenue.totalTransactions,
              dataPoints: overallTaxRevenue.dataPoints,
            },
            filteredTaxRevenue: {
              totalRevenue: filteredTaxRevenue.totalTaxRevenue,
              totalTransactions: filteredTaxRevenue.totalTransactions,
              dataPoints: filteredTaxRevenue.dataPoints,
            },
          },
          walletBalance: wallet?.balance || 0,
        };
      });

      return res.status(200).json({
        success: true,
        message: "Tax analytics fetched successfully",
        data: result,
      });
    } catch (error: any) {
      return res.status(500).json({
        success: false,
        message: "There was a problem getting tax analytics",
        error: error.message || error,
      });
    }
  }

  static async association(req: Request, res: Response) {
    const { filter = AnalyticsFilterRange.DAILY, year } = req.query;
    const userId = req.headers["userid"] as string;

    try {
      const { startDate, endDate } = getDateRange(
        filter as AnalyticsFilterRange,
        parseInt(year as string)
      );

      const result = await withMongoTransaction(async (session) => {
        const matchConditions: any = {
          date: { $gte: startDate, $lte: endDate },
          "association.userId": userId,
        };

        const association = await AssociationModel.findOne({ userId }).session(
          session
        );
        if (!association) {
          throw {
            status: 404,
            message: "Association not found",
          };
        }
        const associationId: string = association._id as string;

        const wallet = await WalletService.getWalletByOwnerId(
          userId,
          WalletTypeEnum.EARNINGS,
          session
        );

         // overall revenue generated today > set based on transactions that the association is a beneficiary to only
         const overallTotalTransactionsAndRevenueToday =
         await AnalyticsService.getOverallUserInvolvedTransactionsAndRevenue({
           filter: AnalyticsFilterRange.DAILY,
           userId,
           session,
         });

          // overall total trxs and revenue generated by the association till date
        const overallAssociationRevenueTillDate = 
        await AnalyticsService.getOverallTotalTransactionsAndRevenueByUserId({
          userId,
          session,
        });

         // get total transactions and revenue generated by the Association based on filter
         const filteredAssociationRevenue =
         await AnalyticsService.getOverallTotalTransactionsAndRevenueByUserId({
           userId,
           filter: filter as AnalyticsFilterRange,
           year: parseInt(year as string),
           session,
         });

        const totalVehicles = await Vehicle.countDocuments({
          association: associationId,
        }).session(session);
        const totalBlacklistedVehicles = await Vehicle.countDocuments({
          association: associationId,
          status: VehicleStatusEnum.BLACKLISTED,
        }).session(session);
        const totalActiveVehicles = await Vehicle.countDocuments({
          association: associationId,
          status: VehicleStatusEnum.ACTIVATED,
        }).session(session);
        const totalInactiveVehicles = await Vehicle.countDocuments({
          association: associationId,
          status: VehicleStatusEnum.INACTIVE,
        }).session(session);
        const totalNotActivateVehicles = await Vehicle.countDocuments({
          association: associationId,
          status: VehicleStatusEnum.NOT_ACTIVATED,
        }).session(session);
        const totalWithExpiredLicense = await Vehicle.countDocuments({
          association: associationId,
          licenseExpiryDate: { $lt: new Date() },
        }).session(session);

        const vehicleCountOverTime = await Vehicle.aggregate([
          {
            $match: {
              association: userId,
              createdAt: { $gte: startDate, $lte: endDate },
            },
          },
          {
            $group: {
              _id: {
                month: { $month: "$createdAt" },
                year: { $year: "$createdAt" },
              },
              count: { $sum: 1 },
            },
          },
          { $sort: { "_id.year": 1, "_id.month": 1 } },
          {
            $project: {
              date: {
                $concat: [
                  { $toString: "$_id.year" },
                  "-",
                  { $toString: "$_id.month" },
                ],
              },
              count: 1,
            },
          },
        ]).session(session);

        return {
          walletBalance: wallet?.balance || 0,
          vehicle: {
            total: totalVehicles,
            blacklisted: totalBlacklistedVehicles,
            active: totalActiveVehicles,
            inactive: totalInactiveVehicles,
            notActivated: totalNotActivateVehicles,
            withExpiredLicense: totalWithExpiredLicense,
          },
          today: {
            revenueToday: overallTotalTransactionsAndRevenueToday.totalAmount,
            totalTransactionsToday:
              overallTotalTransactionsAndRevenueToday.totalTransactions,
          },
          // overallRevenueGenerated: {
          //   totalTransactions:
          //     overallTransactionsAndRevenueTillDate.totalTransactions,
          overallAssociationRevenue: {
            totalRevenue: overallAssociationRevenueTillDate.totalAmount,
            totalTransactions: overallAssociationRevenueTillDate.totalTransactions,
            dataPoints: overallAssociationRevenueTillDate.dataPoints,
          },
          filteredAssociationRevenue: {
            revenue: filteredAssociationRevenue.totalAmount,
            transactions: filteredAssociationRevenue.totalTransactions,
            dataPoints: filteredAssociationRevenue.dataPoints,
          },
          vehicleCountOverTime: vehicleCountOverTime,
        };
      });

      return res.status(200).json({
        success: true,
        message: "Association analytics fetched successfully",
        data: result,
      });
    } catch (error) {
      return res.status(500).json({ error: "An error occurred" });
    }
  }

  static async stakeholder(req: Request, res: Response) {
    const { filter = AnalyticsFilterRange.DAILY, year, status } = req.query;
    const userId = req.headers["userid"] as string;

    try {
      const { startDate, endDate } = getDateRange(
        filter as AnalyticsFilterRange,
        parseInt(year as string)
      );

      const result = await withMongoTransaction(async (session) => {
        const matchConditions: any = {
          date: { $gte: startDate, $lte: endDate },
          "stakeholder.userId": userId,
        };

        const stakeholder = await UserModel.findById(userId).session(
          session
        );
        if (!stakeholder) {
          throw {
            status: 404,
            message: "Stakeholder not found",
          };
        }
        const stakeholderId: string = stakeholder._id as string;

        const wallet = await WalletService.getWalletByOwnerId(
          userId,
          WalletTypeEnum.EARNINGS,
          session
        );

        // profit made by the stakeholder today
        const overallTotalTransactionsAndRevenueToday =
          await AnalyticsService.getOverallUserInvolvedTransactionsAndRevenue({
            filter: AnalyticsFilterRange.DAILY,
            userId,
            session,
          });

        // overall total transactions and revenue generated till date
        const overallTransactionsAndRevenueTillDate =
          await AnalyticsService.getOverallUserInvolvedTransactionsAndRevenue({
            filter: AnalyticsFilterRange.OVERALL,
            userId,
            session,
          });

        const overallStakeholderRevenueTillDate =
          await AnalyticsService.getOverallTotalTransactionsAndRevenueByUserId({
            userId,
            session,
          });

        const filteredStakeholderRevenue =
          await AnalyticsService.getOverallTotalTransactionsAndRevenueByUserId({
            userId,
            filter: filter as AnalyticsFilterRange,
            year: parseInt(year as string),
            session,
          });

      return {
        walletBalance: wallet?.balance || 0,
        today: {
          revenueToday: overallTotalTransactionsAndRevenueToday.totalAmount,
          totalTransactionsToday:
            overallTotalTransactionsAndRevenueToday.totalTransactions,
        },
        overallRevenueGenerated: {
          totalTransactions:
            overallTransactionsAndRevenueTillDate.totalTransactions,
          totalRevenue: overallTransactionsAndRevenueTillDate.totalAmount,
          dataPoints: overallTransactionsAndRevenueTillDate.dataPoints,
        },
        overallStakeholderRevenue: {
          totalRevenue: overallStakeholderRevenueTillDate.totalAmount,
          totalTransactions: overallStakeholderRevenueTillDate.totalTransactions,
        },
        filteredStakeholderRevenue: {
          revenue: filteredStakeholderRevenue.totalAmount,
          transactions: filteredStakeholderRevenue.totalTransactions,
          dataPoints: filteredStakeholderRevenue.dataPoints,
        },
      }
        
      });

      return res.status(200).json({
        success: true,
        message: "Stakeholder analytics fetched successfully",
        data: result,
      });

    } catch (error:any) {
      return res.status(500).json({
        success: false,
        message: "An error occurred",
        error: error.message || error,
      });
    }


  }

  static async superVendor(req: Request, res: Response) {
    const { filter = AnalyticsFilterRange.DAILY, year, status } = req.query;
    const userId = req.headers["userid"] as string;

    try {
      const { startDate, endDate } = getDateRange(
        filter as AnalyticsFilterRange,
        parseInt(year as string)
      );

      const result = await withMongoTransaction(async (session) => {
        const matchConditions: any = {
          date: { $gte: startDate, $lte: endDate },
          status: status || PaymentStatusEnum.SUCCESSFUL,
          "beneficiaries" : {
            $elemMatch: {
              userId: new mongoose.Types.ObjectId(userId)
            }
          }
        };

        const wallet = await WalletService.getWalletByOwnerId(
          userId,
          WalletTypeEnum.DEPOSIT,
          session
        );

        const supervendorRevenue = await TransactionModel.aggregate([
          {
            $match: matchConditions,
          },
          {
            $unwind: "$beneficiaries",
          },
          {
            $match: {
              "beneficiaries.userId": new mongoose.Types.ObjectId(userId)
            },
          },
          {
            $lookup: {
              from: "users",
              localField: "beneficiaries.userId",
              foreignField: "_id",
              as: "beneficiaryDetails",
            },
          },
          {
            $unwind: "$beneficiaryDetails",
          },
          {
            $match: {
              "beneficiaryDetails.role": RoleName.SuperVendor,
            },
          },
          {
            $group: {
              _id: {
                date: { $dateToString: { format: "%Y-%m-%d", date: "$date" } },
              },
              totalRevenue: {
                $sum: {
                  $multiply: [
                    "$amount",
                    { $divide: ["$beneficiaries.percentage", 100] },
                  ],
                },
              },
            },
          },
          {
            $group: {
              _id: null,
              dailyRevenue: {
                $push: { date: "$_id.date", revenue: "$totalRevenue" },
              },
              totalRevenue: { $sum: "$totalRevenue" },
            },
          },
        ]).session(session);

        const totalVendors = await VendorModel.countDocuments({
          superVendor: userId,
        }).session(session);

        // total amount realized from transactions by the vendors of the super vendor
        const totalAmountRealized = await TransactionModel.aggregate([
          {
            $match: matchConditions,
          },
          {
            $unwind: "$beneficiaries",
          },
          {
            $lookup: {
              from: "users",
              localField: "beneficiaries.userId",
              foreignField: "_id",
              as: "beneficiaryDetails",
            },
          },
          {
            $unwind: "$beneficiaryDetails",
          },
          {
            $match: {
              "beneficiaryDetails.superVendor": userId,
            },
          },
          {
            $group: {
              _id: null,
              totalAmount: {
                $sum: "$amount",
              },
            },
          },
        ]).session(session);

        // total amount realized for the day by the vendors of the super vendor
        const totalAmountRealizedToday = await TransactionModel.aggregate([
          {
            $match: {
              date: { $gte: new Date().setHours(0, 0, 0, 0) },
              status: PaymentStatusEnum.SUCCESSFUL,
            },
          },
          {
            $unwind: "$beneficiaries",
          },
          {
            $lookup: {
              from: "users",
              localField: "beneficiaries.userId",
              foreignField: "_id",
              as: "beneficiaryDetails",
            },
          },
          {
            $unwind: "$beneficiaryDetails",
          },
          {
            $match: {
              "beneficiaryDetails.superVendor": userId,
            },
          },
          {
            $group: {
              _id: null,
              totalAmount: {
                $sum: "$amount",
              },
            },
          },
        ]).session(session);

        const totalTransactions = await TransactionModel.countDocuments(
          matchConditions
        ).session(session);

        const superVendorRevenueData = supervendorRevenue[0] || {
          dailyRevenue: [],
          totalRevenue: 0,
        };

        return {
          totalTransactions,
          totalVendors,
          walletBalance: wallet?.balance || 0,
          vendors: {
            overallVendorRevenue: totalAmountRealized[0]?.totalAmount || 0,
            dailyVendorRevenue: totalAmountRealizedToday[0]?.totalAmount || 0,
          },
          supervendorRevenue: {
            total: superVendorRevenueData.totalRevenue,
            dailyRevenue: superVendorRevenueData.dailyRevenue,
          },
        };
      });

      return res.status(200).json({
        success: true,
        message: "Super Vendor analytics fetched successfully",
        data: result,
      });
    } catch (error) {
      return res.status(500).json({ error: "An error occurred" });
    }
  }

  static async vendor(req: Request, res: Response) {
    const { filter = AnalyticsFilterRange.DAILY, year, status } = req.query;
    const userId = req.headers["userid"] as string;

    try {
      const { startDate, endDate } = getDateRange(
        filter as AnalyticsFilterRange,
        parseInt(year as string)
      );

      const result = await withMongoTransaction(async (session) => {
        const matchConditions: any = {
          date: { $gte: startDate, $lte: endDate },
          status: status || PaymentStatusEnum.SUCCESSFUL,
          beneficiaries: {
            $elemMatch: {
              userId: new mongoose.Types.ObjectId(userId)
            }
          }
        };

        const wallet = await WalletService.getWalletByOwnerId(
          userId,
          WalletTypeEnum.DEPOSIT,
          session
        );

        const profitMade = await TransactionModel.aggregate([
          { $match: matchConditions },
          {
            $unwind: "$beneficiaries",
          },
          {
            $match: { 
              "beneficiaries.userId": new mongoose.Types.ObjectId(userId)
            },
          },
          {
            $group: {
              _id: null,
              totalProfit: {
                $sum: {
                  $multiply: [
                    "$amount",
                    { $divide: ["$beneficiaries.percentage", 100] },
                  ],
                },
              },
            },
          },
        ]).session(session);

        const totalTaxProcessed = await TransactionModel.countDocuments(
          matchConditions
        ).session(session);

        const totalAmountTaxProcessed = await TransactionModel.aggregate([
          { $match: matchConditions },
          {
            $group: {
              _id: null,
              totalAmount: { $sum: "$amount" },
            },
          },
        ]).session(session);

        const overallProfit = await TransactionModel.aggregate([
          {
            $match: {
              status: PaymentStatusEnum.SUCCESSFUL,
              beneficiaries: {
                $elemMatch: {
                  userId: new mongoose.Types.ObjectId(userId)
                }
              }
            }
          },
          {
            $unwind: "$beneficiaries",
          },
          {
            $match: { "beneficiaries.userId": 
              new mongoose.Types.ObjectId(userId)
             },
          },
          {
            $group: {
              _id: null,
              totalProfit: {
                $sum: {
                  $multiply: [
                    "$amount",
                    { $divide: ["$beneficiaries.percentage", 100] },
                  ],
                },
              },
            },
          },
        ]).session(session);

        console.log("overall profit", overallProfit);

        const vendorDetails = await VendorModel.findOne({ _id: userId })
          .select("superVendor")
          .populate("superVendor", "email phoneNumber")
          .session(session);

        return {
          walletBalance: wallet?.balance || 0,
          profitMade: profitMade[0]?.totalProfit || 0,
          totalTaxProcessed,
          totalAmountTaxProcessed: totalAmountTaxProcessed[0]?.totalAmount || 0,
          overallProfit: overallProfit[0]?.totalProfit || 0,
          superVendorDetails: vendorDetails?.superVendor || null,
        };
      });

      return res.status(200).json({
        success: true,
        message: "Vendor analytics fetched successfully",
        data: result,
      });
    } catch (error) {
      return res.status(500).json({ error: "An error occurred" });
    }
  }

}
